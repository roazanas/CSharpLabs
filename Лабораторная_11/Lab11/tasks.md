
   1. ### **Пространство имен System.Collections.**
Пространство имен System.Collections содержит множество интерфейсов и классов, которые определяют и реализуют коллекции различных типов. Коллекции упрощают программирование, предлагая уже готовые решения для построения структур данных, разработка которых "с нуля" отличается большой трудоемкостью. Речь идет о встроенных коллекциях, которые поддерживают, например, функционирование стеков, очередей и хеш-таблиц. Коллекции пользуются большой популярностью у всех С#-программистов.

В пространстве имен System.Collections определены наборы стандартных коллекций и интерфейсов, которые реализованы в этих коллекциях.

**Интерфейсы**

|Интерфейс|Назначение|
| :- | :- |
|ICollection|Определяет общие характеристики (например, размер) для набора элементов|
|IComparer|Позволяет сравнивать два объекта|
|IDictionary|Позволяет представлять содержимое объекта в виде пар «имя-значение»|
|IDictionaryEnumenator|Используется для нумерации содержимого объекта, поддерживающего интерфейс IDictionary.|
|IEnumerable|Возвращает интерфейс IEnumerator для указанного объекта|
|IEnumerator|Обычно используется для поддержки оператора foreach в отношении объектов|
|IHashCodeProvider|Возвращает хеш-код для реализации типа с применением выбранного пользователем алгоритма хеширования|
|IList|Поддерживает методы добавления, удаления и индексирования элементов в списке объектов|

Основополагающим для всех коллекций является реализация **перечислителя** (нумератора), который поддерживается интерфейсами **IEnumerator и IEnumerable**. Перечислитель обеспечивает стандартизованный способ поэлементного доступа к содержимому коллекции. Поскольку каждая коллекция должна реализовать интерфейс IEnumerable, к элементам любого класса коллекции можно получить доступ с помощью методов, определенных в интерфейсе IEnumerator. Следовательно, после внесения небольших изменений код, который позволяет циклически опрашивать коллекцию одного типа, можно успешно использовать для циклического опроса коллекции другого типа. Содержимое коллекции любого типа можно опросить с помощью нумератора, используемого в цикле foreach.

**Интерфейс ICollection** можно назвать фундаментом, на котором построены все коллекции. В нем объявлены основные методы и свойства, без которых не может обойтись ни одна коллекция. Он наследует интерфейс IEnumerable.

ICollection включает в себя свойство Count, которое содержит количество элементов, хранимых в коллекции в данный момент. Если свойство Count равно нулю, значит, коллекция пуста. 

Поскольку интерфейс ICollection наследует интерфейс IEnumerable, он также включает его единственный метод GetEnumerator ( ) :

IEnumerator GetEnumerator(), который возвращает нумератор коллекции.

**Интерфейс IList** наследует интерфейс ICollection и определяет поведение коллекции, доступ к элементам которой разрешен посредством индекса с отсчетом от нуля. Помимо методов, определенных в интерфейсе ICollection, интерфейс IList определяет и собственные методы.

**Методы интерфейса IList**

|Метод|Описание|
| :- | :- |
|int Add(object obj)|Добавляет объект obj* в вызывающую коллекцию. Возвращает индекс, по которому этот объект сохранен|
|void Clear()|Удаляет все элементы из вызывающей коллекции|
|bool Contains(object obj)|Возвращает значение true , если вызывающая коллекция содержит объект, переданный в параметре obj*,* и значение false в противном случае|
|int IndexOf(object obj)|Возвращает индекс объекта obj,* если он (объект) содержится в вызывающей коллекции. Если объект obj не обнаружен, метод возвращает -1|
|void Insert(int idx, object obj)|Вставляет в вызывающую коллекцию объект obj* по индексу, заданному параметром idx.* Элементы, находившиеся до этого по индексу idx и далее, смещаются вперед, чтобы освободить место для вставляемого объекта obj.|
|void Remove(object obj)|Удаляет из вызывающей коллекции объект, расположенный по индексу, заданному параметром idx. Элементы, находившиеся до этого за удаленным элементом, смещаются назад, чтобы ликвидировать образовавшуюся "брешь"|
|void RemoveAt(int idx)|Удаляет первое вхождение объекта obj* из вызывающей коллекции. Элементы, находившиеся до этого за удаленным элементом, смещаются назад, чтобы ликвидировать образовавшуюся "брешь"|

В классе IList определены свойства:

- bool IsFixedSize { get; }
- bool IsReadOnly { get; }

Если коллекция имеет фиксированный размер, свойство IsFixedSize принимает значение true. Это означает, что в такую коллекцию нельзя вставлять элементы и удалять их из нее. Если коллекция предназначена только для чтения, свойство IsReadOnly имеет значение true. Это говорит о том, что содержимое коллекции изменению не подлежит.

**Интерфейс IDictionary** определяет поведение коллекции, которая устанавливает соответствие между уникальными ключами и значениями. Ключ - это объект, который используется для получения соответствующего ему значения. Следовательно, коллекция, которая реализует интерфейс IDictionary, служит для хранения пар ключ/значение. Сохраненную однажды пару можно затем извлечь по заданному ключу. Интерфейс IDictionary наследует интерфейс ICollection.

**Методы интерфейса IDictionary**

|Метод|Описание|
| - | - |
|void Add( object k, object v)|Добавляет в вызывающую коллекцию пару ключ/значение, заданную параметрами к и v. Ключ к не должен быть нулевым|
|void Clear()|Удаляет все пары ключ/значение из вызывающей коллекции|
|bool Contains (object k)|Возвращает значение true , если вызывающая коллекция содержит объект к в качестве ключа. В противном случае возвращает значение false|
|iDictionaryEnumerator GetEnumerator()|Возвращает нумератор для вызывающей коллекции|
|void Remove (object k)|Удаляет элемент, ключ которого равен значению k|

В интерфейсе IDictionary определены следующие свойства:

- bool  isFixedSize {get ;} Равно значению true, если словарь имеет фиксированный размер.
- bool isReadOnly get; } Равно значению true , если словарь предназначен только для чтения.
- iCollectionKeys { get; } Получает коллекцию ключей.
- iCollection Values { get; } Получает коллекцию значений.

В пространстве имен System.Collections опреден тип структуры с именем DictionaryEntry. Коллекции, в которых хранятся пары ключ/значение, используют для их хранения объект типа DictionaryEntry. В этой структуре определены следующие два свойства:

- public object Key { get; set; }
- public object Value { get; set; }

Эти свойства используются для получения доступа к ключу или к соответствующему ему значению. Объект типа DictionaryEntry можно создать с помощью следующего конструктора:

public DictionaryEntry(object кey, object value)

Здесь параметр key принимает ключ, а параметр value — значение.

**Классы коллекций общего назначения:**

|Класс|Назначение |Интерфейсы|
| - | - | - |
|ArrayList|<p>Массив, динамически</p><p>изменяющий свой размер</p>|IList,  ICollection, IEnumerable, ICloneable|
|Hashtable|Хеш-таблица|<p>IDictionary, ICollection, IEnumerable,</p><p>ICloneable</p>|
|Queue|Очередь|ICollection, ICloneable, IEnumerable|
|SortedList|<p>Коллекция, отсортированная</p><p>по ключам. Доступ</p><p>к элементам — по ключу</p><p>или по индексу</p>|<p>IDictionary, ICollection, IEnumerable,</p><p>ICloneable</p>|
|Stack|Стек|ICollection, IEnumerable|

Класс ArrayList предназначен для поддержки динамических массивов, которые при необходимости могут увеличиваться или сокращаться. В С# стандартные массивы имеют фиксированную длину, которая не может измениться во время выполнения программы. Это означает, что программист должен знать заранее, сколько элементов будет храниться в массиве. Но иногда до выполнения программы нельзя точно сказать, массив какого размера понадобится. В таких случаях и используется класс ArrayList. Объект класса ArrayList представляет собой массив переменной длины, элементами которого являются объектные ссылки. Любой объект класса ArrayList создается с некоторым начальным размером. При превышении этого размера коллекция автоматически его увеличивает. В случае удаления объектов массив можно сократить. 

Класс ArrayList реализует интерфейсы ICollection, IList, IEnumerable и ICloneable. В классе ArrayList определены следующие конструкторы:

- public ArrayList() - предназначен для создания пустого ArrayList-массива.
- public ArrayList(ICollection с) - предназначен для создания массива, который инициализируется элементами и емкостью коллекции, заданной параметром с.
- public ArrayList(int capacity) - создает массив с заданным начальным размером.

  Например:

- ArrayList arrl = new ArrayList(); // создается пустой массив 
- ArrayLi st arr2 = new ArrayList(1000); // создается массив из 1000 элементов
- ArrayList arr3 = new ArrayList();//создается пустой массив
- arr3.Capacity = 1000; // количество элементов задается

**Основные элементы класса ArrayList**

|Элемент|Вид|Назначение|
| - | - | - |
|Capacity|Свойство|<p>Количество элементов, которые могут</p><p>храниться в массиве</p>|
|Count|Свойство|Фактическое количество элементов массива|
|Item|Свойство|Получить или установить значение элемента по заданному индексу|
|Add|Метод|Добавление элемента в конец массива|
|AddRange|Метод|Добавление серии элементов в конец массива|
|BinarySearch|Метод|Двоичный поиск в отсортированном массиве или его части|
|Clear|Метод|Удаление всех элементов из массива|
|Clone|Метод|<p>Поверхностное копирование элементов одного массива</p><p>в другой массив</p>|
|CopyTo|Метод|Копирование всех или части элементов массива в одномерный массив|
|GetRange|Метод|Получение значений подмножества элементов массива в виде объекта типа ArrayList|
|Index|Метод|Поиск первого вхождения элемента в массив (возвращает индекс найденного элемента или -1, если элемент не найден)|
|Insert|Метод|Вставка элемента в заданную позицию (по заданному индексу)|
|InserRange|Метод|Вставка группы элементов, начиная с заданной позиции|
|LastIndexOf|Метод|Поиск последнего вхождения элемента в одномерный массив|
|Remove|Метод|Удаление первого вхождения заданного элемента в массив|
|RemoveAt|Метод|Удаление элемента из массива по заданному индексу|
|RemoveRange |Метод|Удаление группы элементов из массива|
|Reverse |Метод|Изменение порядка следования элементов на обратный|
|SetRange |Метод|Установка значений элементов массива в заданном диапазоне|
|Sort |Метод|Упорядочивание элементов массива или его части|
|<p>TrimToSize </p><p></p>|Метод|<p>Установка емкости массива равной фактическому количеству</p><p>элементов</p>|

**Класс Hashtable** предназначен для создания коллекции, в которой для хранения объектов используется хеш-таблица. Возможно, многим известно, что в хеш-таблице для хранения информации используется механизм, именуемый хешированием (hashing). Суть хеширования состоит в том, что для определения уникального значения, которое называется хеш-кодом, используется информационное содержимое соответствующего ему ключа. Хеш-код затем используется в качестве индекса, по которому в таблице отыскиваются данные, соответствующие этому ключу. Преобразование ключа в хеш-код выполняется автоматически, т.е. сам хеш-код вы даже не увидите. Но преимущество хеширования  -  в том, что оно позволяет сохранять постоянным время выполнения таких операций, как поиск, считывание и запись данных, даже для больших объемов информации. Класс Hashtable реализует интерфейсы IDictionary, ICollection, IEnumerable, ISerializable, IDeserializationCallback и ICloneable.

В классе Hashtable определено множество конструкторов, включая следующие:

- public Hashtable() - позволяет создать стандартный пустой объект класса Hashtable.
- public Hashtable(IDictionary с) - для инициализации Hashtable-объекта используются элементы заданной коллекции с.
- public Hashtable(int capacity) - инициализирует емкость создаваемой хеш-таблицы значением capacity.
- public Hashtable(int capacity, float fillRatio) - инициализирует емкость значением capacity), а коэффициент заполнения значением fillRatio. Значение коэффициента заполнения, которое должно попадать в диапазон 0,1-1,0, определяет степень заполнения хеш-таблицы. Например, если указать коэффициент заполнения 0,7, то таблица будет заполнена на 70%. После заполнения таблицы на 70% при добавлении в нее элемента, ее размер увеличивается в 2 раза. 

**Основные элементы класса Hashtable**

|Элемент|Вид|Назначение|
| :- | :- | :- |
|Keys|Свойство|Получить коллекцию ключей |
|Values|Свойство|Получить коллекцию значений|
|ContainsKey|Метод|<p>Возвращает true , если в вызывающей</p><p>коллекции содержится ключ, заданный параметром*.* В противном случае возвращает значение false.</p>|
|ContainsValue|Метод|<p>Возвращает true , если в вызывающей</p><p>коллекции содержится значение, заданное параметром*.* В противном случае возвращает значение false.</p>|

**Класс SortedList** предназначен для создания коллекции, которая хранит пары ключ/значение в упорядоченном виде, а именно отсортированы по ключу. Класс SortedList реализует интерфейсы IDictionary, ICollection, IEnumerable и ICloneable.

В классе SortedList определено несколько конструкторов, включая следующие:

- public SortedList() - позволяет создать пустую коллекцию.
- public SortedList(IDictionary c) -  создает SortedList-коллекцию, которая инициализируется элементами и емкостью коллекции, заданной параметром с.
- public SortedList(int capacity) - создает пустой SortedList-список, который инициализируется емкостью, заданной параметром capacity.
- public SortedList(IComparer comp) -  позволяет задать метод сравнения, который должен использоваться для сравнения объектов списка при их добавлении в коллекцию. С помощью этой формы создается пустая коллекция.

  Емкость SortedList-коллекции увеличивается автоматически, если в этом возникает необходимость, при добавлении элементов. Если окажется, что текущая емкость может быть превышена, она удваивается. В классе SortedList помимо методов, определенных в реализованных им интерфейсах, также определены собственные методы. 

  |Элемент|Вид|Назначение|
  | :- | :- | :- |
  |Keys|Свойство|Получить коллекцию ключей |
  |Values|Свойство|Получить коллекцию значений|
  |ContainsKey|Метод|Возвращает значение true , если в коллекции содержится ключ, заданный параметром. В противном случае возвращает значение false|
  |ContainsValue|Метод|Возвращает значение true , если в коллекции содержится значение, заданное параметром. В противном случае возвращает значение false|
  |GetBylndex|Метод|Возвращает значение, индекс которого задан параметром|
  |GetKey|Метод|Возвращает ключ, индекс которого задан параметром|
  |GetKeyList()||Возвращает iList-коллекцию ключей, хранимых в вызывающей SortedList-коллекции|
  |GetValueList()||Возвращает iList-коллекцию значений, хранимых в вызывающей SortedList-коллекции|
  |IndexOfKe||Возвращает индекс ключа, заданного параметром к. Возвращает значение - 1 , если в списке нет заданного ключа|
  |IndexOfValue||Возвращает индекс первого вхождения значения, заданного параметром v. Возвращает -1, если в списке нет заданного ключа|
  |SetBylndex(int idx, object v)||Устанавливает значение по индексу, заданному параметром idx, равным значению, переданному в параметре v|
  |TrimToSize()||Устанавливает свойство capacity равным значению свойства Count|

  Подобно Наshtable -коллекции, SortedList-список хранит пары ключ/значение в форме структуры типа DictionaryEntry, но с помощью методов и свойств, определенных в классе SortedList, программисты обычно получают отдельный доступ к ключам и значениям.

  **Класс Stack** представляет собой список, добавление и удаление элементов к которому осуществляется по принципу "последним пришел — первым обслужен" (last-in, first-out, LIFO). 

  Класс коллекции, предназначенный для поддержки стека, называется Stack. Он реализует интерфейсы ICollection, IEnumerable и ICloneable. Стек — это динамическая коллекция, которая при необходимости увеличивается, чтобы принять для хранения новые элементы, причем каждый раз, когда стек должен расшириться, его емкость удваивается.

  В классе Stack определены следующие конструкторы:

- public Stack() - предназначен для создания пустого стека.
- public Stack(int capacity)- создает пустой стек с начальной емкостью, заданной параметром capacity
- public Stack(ICollection c) - служит для построения стека, который инициализируется элементами и емкостью коллекции, заданной параметром с.

В классе Stack помимо методов, определенных в реализованных им интерфейсах, также определены собственные методы. 

|Элемент|Вид|Назначение|
| :- | :- | :- |
|Contains(object v)|Метод|Возвращает значение true , если объект v содержится в вызывающем стеке. В противном случае возвращает значение false|
|Clear()|Метод|Устанавливает свойство count равным нулю, тем самым эффективно очищая стек|
|Peek()|Метод|Возвращает элемент, расположенный в вершине стека, но не удаляет его|
|Pop()|Метод|Возвращает элемент, расположенный в вершине стека, и удаляет его|
|Push(object v)|Метод|Помещает объект v в стек|
|ToArray()|Метод|Возвращает массив, который содержит копии элементов вызывающего стека|

Класс коллекции, предназначенный для поддержки очереди, называется **Queue.** Он реализует интерфейсы iCollection, IEnumerable и ICloneable. Очередь — это динамическая коллекция, которая при необходимости увеличивается, чтобы принять для хранения новые элементы, причем каждый раз, когда такая необходимость возникает, текущий размер очереди умножается на коэффициент роста, который по умолчанию равен значению 2,0.

В классе Queue определены следующие конструкторы:

- public Queue() - предназначен для создания пустой очереди и коэффициентом роста 2,0.
- public Queue (int capacity) - создает пустую очередь с начальной емкостью, заданной параметром capacity, и коэффициентом роста 2,0.
- public Queue (int capacity, float growFact)- позволяет задать коэффициент роста посредством параметра growFact.
- public Queue (ICollection c) - служит для создания очереди, которая инициализируется элементами и емкостью коллекции, заданной параметром с.

Помимо методов, определенных в интерфейсах, которые реализует класс Queue, также определены собственные методы. 

|Элемент|Вид|Назначение|
| :- | :- | :- |
|Contains (object v)|Метод|Возвращает значение true , если объект v содержится в вызывающей очереди. В противном случае возвращает значение false|
|Clear()|Метод|Устанавливает свойство Count равным нулю, тем самым эффективно очищая очередь|
|Dequeue ()|Метод|Возвращает объект из начала вызывающей очереди, Возвращаемый  объект из очереди удаляется|
|Enqueue(object v)|Метод|Добавляет объект v в конец очереди|
|Peek ()|Метод|Возвращает объект из начала вызывающей очереди, но не удаляет его|
|тоАггау ()|Метод|Возвращает массив, который содержит копии элементов из вызывающей очереди|
|TrimToSize()|Метод|Устанавливает свойство Capacity равным значению свойства Count|

1. ### **Обобщенные коллекции. Пространство имен System.Collections.Generic.**
Во вторую версию библиотеки .NET добавлены параметризованные коллекции для представления основных структур данных, применяющихся при создании программ, — стека, очереди, списка, словаря и т. д. Эти коллекции, расположенны в пространстве имен **System.Collections.Generic** и, в основном, дублируют аналогичные коллекции пространства имен **System.Collections.**

**Параметризованные коллекции библиотеки .NET**

|**Класс- прототип**|**Обычный класс**|
| :- | :- |
|Comparer <T> |Comparer|
|Dictionary <K,T>|HashTable|
|LinkedList <T>|-|
|List <T> |ArrayList|
|Queue<T>|Queue|
|SortedDictionary <K,T>|SortedList|
|Stack <T>|Stack|

Параметром класса-прототипа является тип данных, с которым он работает (T – это тип, который является параметром коллекции, т. е. вместо него можно подставить любой другой тип данных).

В коллекциях, которые мы рассматривали ранее, хранятся ссылки на объекты типа object. Когда значение структурного типа приводится к типу object (или к типу того интерфейса, который реализован системой) выполняется операция упаковки – явного преобразования из типа значений в тип ссылок. Эта операция выполняется автоматически и не требует вмешательства программиста. Обратной операцией является распаковка – значение объекта присваивается переменной.

У таких коллекций есть два недостатка:

- в одной и той же коллекции можно хранить элементы любого типа, следовательно, ошибки при помещении в коллекцию невозможно проконтролировать на этапе компиляции, а при извлечении элемента требуется его явное преобразование;
- при хранении в коллекции элементов значимых типов выполняется большой объем действий по упаковке и распаковке элементов, что в значительной степени снижает эффективность работы.

  **Пример 1.** 

  class Document : IComparable

  `    `{. . . . }

  class Receipt : Document

  `    `{. . . . }

  class Program

  `    `{

  `        `static void Main(string[] args)

  `        `{

  `            `List<Document> ReceiptGroup = new List<Document>();//создали коллекцию

  `            `ReceiptGroup.Add(new Receipt("Иванов",18,1,4));

  `            `ReceiptGroup.Add(new Receipt("Петров",19,2,5));

  `            `ReceiptGroup.Add(new Receipt("Сидоров",21,5,4.5));

  `            `ReceiptGroup.Add(new Document("Семенов",23));

  `            `Console.WriteLine("Студенческая группа");

  `            `foreach (Document x in ReceiptGroup)

  `           	 `x.Show();

  `            `List<int> Vector = new List<int>();

  `            `Vector.Add(1);

  `            `Vector.Add(5);

  `            `Vector.Add(4);

  `            `Console.WriteLine("\nВектор"); 

  `            `foreach (int y in Vector)

  `                `Console.Write(y + " ");

  `            `Console.WriteLine();

  `        `}

  `    `}

  ![](Aspose.Words.9b60b0f7-4196-4b09-9281-6b0c6a12c809.002.png)

  Коллекция ReceiptGroup содержит объекты пользовательских классов иерархии классов Document->Receipt.

  В коллекции, для которой объявлен тип элементов Document, благодаря полиморфизму можно хранить элементы любого производного класса, но не элементы других типов.

  Казалось бы, по сравнению с обычными коллекциями это ограничение, а не универсальность, однако на практике коллекции, в которых действительно требуется хранить значения различных, не связанных межу собой типов, почти не используются.

  Достоинством же такого ограничения является то, что компилятор может выполнить контроль типов во время компиляции, а не выполнения программы, что повышает ее надежность и упрощает поиск ошибок.

  Коллекция  Vector состоит из целых чисел, причем для работы с ними не требуются ни операции упаковки и распаковки, ни явные преобразования типа при получении элемента из коллекции, как это было в обычных коллекциях.

  Классы-прототипы называют также родовыми или шаблонными, поскольку они представляют собой образцы, по которым во время выполнения программы строятся конкретные классы. Использование стандартных параметризованных коллекций для хранения и обработки данных является хорошим стилем программирования, поскольку позволяет сократить сроки разработки программ и повысить их надежность. Рекомендуется тщательно изучить по документации свойства и методы этих классов и выбирать наиболее подходящие в зависимости от решаемой задачи.

  **Параметризованные интерфейсы библиотеки .NET.**

  |**Параметризованный интерфейс**|**Обычный интерфейс**|
  | :- | :- |
  |ICollection<T> |ICollection|
  |IComparable<T>|IComparable|
  |IDictionary<Т> |IDictionary|
  |IEnumerable<T>|I Enumerable|
  |IEnumerator<T> |I Enumerator|
  |IList<T>|IList|

При работе с коллекцией использовать объекты из иерархии классов, разработанной в работе №10. 
### **2.3.  Задание 3.**
1. ` `Создать иерархию классов (базовый  – производный) в соответствии с вариантом (см. лаб. раб. №10).
1. В производном классе определить свойство или метод, которое возвращает ссылку на объект базового класса (это свойство должно возвращать объект  базового класса). Например, для иерархии классов Document-Receipt в классе производном классе Receipt можно определить свойство

`   `public Document BaseDocument

`        `{

`            `get

`            `{

`             `return new Document(name, age);//возвращает объект базового класса

`            `}

`        `}

1. Определить класс TestCollections, который содержит поля следующих типов 

Коллекция\_1< TValue > ; 

Коллекция\_1<string> ; 

Коллекция\_2<TKey, TValue> ; 

Коллекция\_2<string, TValue> . 

где тип ключа TKey и тип значения TValue связаны отношением базовый-производный (см. задание 1), Коллекция\_1 и Коллекция\_2 – коллекции из пространства имен System.Collections.Generic.

Например:

List<Receipt> col1=new List<Receipt>();

List<string> col2=new List<Receipt>();

Dictionary<Document, Receipt> col2=new Dictionary<Document, Receipt>();

Dictionary<string, Receipt> col2=new Dictionary<string, Receipt>();


1. Написать конструктор класса TestCollections, в котором создаются коллекции с заданным числом элементов (1000 элементов). 
1. Предусмотреть автоматическую генерацию элементов коллекции таким образом, что каждый объект (Receipt) содержит подобъект базового класса (Document). Все четыре коллекции должны содержать одинаковое число элементов. Сами элементы также должны быть одинаковые, т.е. сгенерировали элемент производного класса и на его основе заполнили элементами все 4 коллекции. В коллекциях, где должны быть строки, для заполнения используется метод ToString().
1. Предусмотреть методы для работы с  коллекциями (добавление и удаление элементов).
1. Для четырех разных элементов – первого, центрального, последнего и элемента, не входящего в коллекцию – надо измерить время поиска элемента в коллекциях Коллекция\_1< TValue > и Коллекция\_1<string> с помощью метода Contains;  элемента по ключу в коллекциях Коллекция\_2< TKey, TValue> и Коллекция\_2 <string, TValue > с помощью метода ContainsKey; значения элемента в коллекции Коллекция\_2< TKey, TValue > с помощью метода ContainsValue.  Обратите внимание на то, что искать нужно сами элементы, а не ссылки на них!
1. Объяснить полученные результаты.
## **3. Варианты** 

|№ варианта|Задание 1|Задание 2|Задание 3<br>(Коллекция\_1)|Задание 3<br>(Коллекция\_2)||
| :-: | :-: | :-: | :-: | :-: | :- |

|8|Hashtable|Dictionary<K,T>|List <T> |SortedDictionary <K,T>||


## **4. Содержание отчета**

**Для задания 11.3** 

1. Диаграмма классов (в том числе иерархия классов для объектов, помещаемых в коллекцию).
1. Пример демонстрационной  программы.
1. Полученные результаты.
1. Анализ полученных результатов (объяснить, какая из рассмотренных коллекций оказалась самой быстродействующей, и почему). 
1. ## **Методические указания**
1. Для измерения времени поиска рекомендуется использовать класс Stopwatch из библиотеки System.Diagnostics. Время лучше измерять в тиках, незначащие нули не показывать.  
1. При поиске элемента обратите внимание на то, что искать нужно сами элементы (содержимое), а не ссылки на них. 

   Например:

   //запомнили в first ссылку на первый элемент

   Document first = ts.collection1.First; 

   //запомнили в first содержимое первого элемента

   Document first = new Document(ts.collection1.First.Name, ts.collection1.First.Age) ; 

1. Обязательно проверьте, был ли найден элемент, т.е. какое значение вернул метод Contains().

